In questa terza lezione affronteremo di nuovo gli stessi problemi della prima e seconda lezione (lettura di dati da un file, calcolo di media e mediana) utilizzando una evoluzione del contenitore di dati Vettore: possiamo rendere questa classe più flessibile in modo che sia capace di immagazzinare qualsiasi tipo di dato ( e non necessariamente dei numeri double ) ? Nella seconda parte spingeremo ancora oltre la generalizzazione imparando ad usare il contenitore vector della STL . Quindi in sintesi :
Tipo di dato da leggere è constituito da numeri double.
Tipo di contenitore di dati è una generalizzazione della classe Vettore della lezione 2 o il contenitore vector della STL.
Operazioni sui dati vengono svolte mediante funzioni che agiscono su oggetti di tipo Vettore o vector.

Per incominciare ripassiamo brevemente cosa sono le funzioni e le classi template.

ESERCIZIO 3.0 - Evoluzione della classe Vettore in una classe template (da consegnare):
Proviamo a rendere la classe Vettore della lezione scorsa una classe template in modo che possa in linea di principio immagazzinare oggeti di un tipo generico T. Notate che quando usiamo classi o funzioni template non applichiamo la separazione tra header file (.h) e file di implementazione (.cxx) ma codifichiamo tutto dentro l'header file. Questo perchè non sarebbe possibile per il compilatore compilare separatamente un set di funzioni o una classe senza sapere i tipi esatti con cui verranno utilizzati.

ESERCIZIO 3.1 - Codice di analisi dati utilizzando la classe vector (da consegnare):
Vediamo come possiamo ora fare uso di un contenitore "ufficiale" del c++, la classe vector. Questo particolare contenitore non è altro che una classe template sulla falsariga della nostra Vettore. La particolarità di questa classe sta nel fatto che la sua dimensione può non essere nota a priori: la costruzione del vettore può avvenire "aggiungendo in coda" (push_back(x)) gli elementi man mano che si rendono disponibili. Vedremo nel seguito alcuni esempi, in caso è possibile trovare più materiale per esempio in questa referenza.
Notate anche che per contenitori della STL (come il vector) che stiamo andando ad utilizzare, esistono delle funzioni standard che possono essere utilizzate senza sforzo ( vedi nel nostro esempio la funzione sort ).

Notate che la classe vector ci libera completamente dalla necessità di conoscere in anticipo la quantità di dati da caricare. Questo ci permette per esempio di scrivere una funzione che legga automaticamente tutti i dati che trova in un file senza sapere a priori quanti sono.

ESERCIZIO 3.2 - Analisi dati con vector e visualizzazione dei dati (da consegnare):
Proviamo ora ad aggiungere all'esercizio precedente la possibilità di visualizzare i dati letti da file.
Un modo semplice per visualizzare graficamente la distribuzione di un set di dati è quello di usare un istrogramma (TH1F) di ROOT. Le classi di ROOT sono molto comode da usare perchè possiamo facilmente utilizzarle in un codice C++ Per fare questo dobbiamo ricordarci di :
Includere l'header file (.h) di ogni oggetto di ROOT che pensiamo di utilizzare (TApplication, TH1F, TGraph, TCanvas).
Modificare il Makefile in modo che sia in grado da solo di trovare il path degli header files necessari ($INCS) e le librerie precompilate da linkare ($LIBS).
